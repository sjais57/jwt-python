✅ STEP 1: Allow headers to be dynamic (YOU ALREADY DID THIS)

headers: Dict[str, Any] = field(default_factory=dict)


✅ STEP 2: Define a Dynamic Header Contract in Manifest

"headers": {
  "Authorization": {
    "type": "function",
    "module": "utils.api_key",
    "function": "get_fedsso_auth_token",
    "args": {
      "client_id": "${environments.${environment}.secrets.client_id}",
      "client_secret": "${environments.${environment}.secrets.client_secret}",
      "token_url": "${environments.${environment}.urls.fedsso_url}"
    },
    "prefix": "Bearer "
  }
}


✅ STEP 3: Add Header Resolution Logic (CORE FIX)

async def _resolve_headers(self, headers: Dict[str, Any]) -> Dict[str, str]:
    resolved = {}

    for key, value in headers.items():
        # Static header
        if isinstance(value, str):
            resolved[key] = value
            continue

        # Dynamic header via function
        if isinstance(value, dict) and value.get("type") == "function":
            module_name = value["module"]
            function_name = value["function"]
            args = value.get("args", {})
            prefix = value.get("prefix", "")

            module = __import__(module_name, fromlist=[function_name])
            func = getattr(module, function_name)

            # Call token function (sync-safe)
            token = func(**args)

            resolved[key] = f"{prefix}{token}"
            continue

        raise ValueError(f"Unsupported header format for {key}")

    return resolved

✅ STEP 4: Inject Resolved Headers Before HTTP Call
Modify _perform_check() ONLY HERE:

resolved_headers = await self._resolve_headers(target.headers)

request_kwargs = {
    "method": target.method,
    "url": target.url,
    "headers": resolved_headers,
    "timeout": target.timeout_seconds,
}

